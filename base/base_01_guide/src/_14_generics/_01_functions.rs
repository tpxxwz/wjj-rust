// 函数
// 同样的规则也适用于函数：当类型 T 前面加上 <T> 时，它就变成了泛型。
//
// 使用泛型函数有时需要明确指定类型参数。
// 这种情况可能出现在函数返回类型是泛型时，或者编译器没有足够信息推断必要的类型参数时。
//
// 明确指定类型参数的函数调用看起来像这样：fun::<A, B, ...>()。

struct A;          // 具体类型 `A`
struct S(A);       // 具体类型 `S`
struct SGen<T>(T); // 泛型 `SGen`

// 以下函数都获取传入变量的所有权
// 并立即离开作用域，释放该变量

// 定义函数 `reg_fn`，接受一个 `S` 类型的参数 `_s`
// 由于没有 `<T>`，所以这不是泛型函数
fn reg_fn(_s: S) {}

// 定义函数 `gen_spec_t`，接受一个 `SGen<T>` 类型的参数 `_s`
// 虽然明确给定了类型参数 `A`，但因为 `A` 并未被指定为
// `gen_spec_t` 的泛型类型参数，所以这个函数不是泛型的
fn gen_spec_t(_s: SGen<A>) {}

// 定义函数 `gen_spec_i32`，接受一个 `SGen<i32>` 类型的参数 `_s`
// 明确指定了类型参数 `i32`，这是一个具体类型
// 由于 `i32` 不是泛型类型，所以这个函数也不是泛型的
fn gen_spec_i32(_s: SGen<i32>) {}

// 定义函数 `generic`，接受一个 `SGen<T>` 类型的参数 `_s`
// 由于 `SGen<T>` 前面有 `<T>`，所以这个函数是关于 `T` 的泛型函数
fn generic<T>(_s: SGen<T>) {}

#[wjj_lib::gen_test]
fn main() {
    // 使用非泛型函数
    reg_fn(S(A));          // 具体类型
    gen_spec_t(SGen(A));   // 隐式指定类型参数 `A`
    gen_spec_i32(SGen(6)); // 隐式指定类型参数 `i32`

    // 为 `generic()` 显式指定类型参数 `char`
    generic::<char>(SGen('a'));

    // 为 `generic()` 隐式指定类型参数 `char`
    generic(SGen('c'));
}

