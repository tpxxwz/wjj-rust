// 显式注解
// 借用检查器使用显式生命周期注解来确定引用应该有效多长时间。
// 在生命周期没有被省略1的情况下，Rust 需要显式注解来确定引用的生命周期。
// 显式注解生命周期的语法使用撇号字符，如下所示
//
// foo<'a>
// `foo` 有一个生命周期参数 `'a`
//
// 类似于闭包，使用生命周期需要泛型。
// 此外，这种生命周期语法表示 foo 的生命周期不能超过 'a 的生命周期。
// 类型的显式注解形式为 &'a T，其中 'a 已经被引入。
//
// 在有多个生命周期的情况下，语法类似：
// foo<'a, 'b>
// // `foo` 有生命周期参数 `'a` 和 `'b`
// 在这种情况下，foo 的生命周期不能超过 'a 或 'b 的生命周期。
//
// 请看下面的例子，展示了显式生命周期注解的使用：
// `print_refs` 接受两个 `i32` 的引用，它们有不同的
// 生命周期 `'a` 和 `'b`。这两个生命周期都必须
// 至少和函数 `print_refs` 一样长。
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x 是 {}，y 是 {}", x, y);
}

// 一个没有参数但有生命周期参数 `'a` 的函数。
fn failed_borrow<'a>() {
    let _x = 12;

    // 错误：`_x` 的生命周期不够长
    // let _y: &'a i32 = &_x;
    // 尝试在函数内部使用生命周期 `'a` 作为显式类型标注会失败，
    // 因为 `&_x` 的生命周期比 `_y` 的短。
    // 短生命周期无法强制转换为长生命周期。
}

#[test]
fn main() {
    // 创建将要被借用的变量。
    let (four, nine) = (4, 9);

    // 将两个变量的借用（`&`）传递给函数。
    print_refs(&four, &nine);
    // 任何被借用的输入必须比借用者存活更久。
    // 换句话说，`four` 和 `nine` 的生命周期必须
    // 比 `print_refs` 的生命周期更长。

    failed_borrow();
    // `failed_borrow` 不包含任何引用来强制 `'a` 比函数的生命周期更长，
    // 但 `'a` 实际上更长。
    // 因为生命周期从未被约束，它默认为 `'static`。
}
