// 绑定
// 间接访问变量时，无法在分支中使用该变量而不重新绑定。match 提供了 @ 符号，用于将值绑定到名称：

// 一个返回 `u32` 的 `age` 函数。
fn age() -> u32 {
    15
}

fn some_number() -> Option<u32> {
    Some(42)
}

#[wjj_lib::gen_test]
fn main() {
    println!("告诉我你是什么类型的人");

    match age() {
        0 => println!("我还没有过第一个生日"),
        // 我们可以直接 `match` 1 ..= 12，但那样的话如何确定
        // 孩子的确切年龄呢？
        // 可以 `match` n 并使用 `if` 守卫，但这并不是
        // 穷尽性检查。
        // （虽然在这种情况下无关紧要，因为底部有一个
        // "兜底" 模式）
        // 因此，将 1 ..= 12 序列绑定到 `n`。
        // 现在可以报告年龄了。
        n @ 1..=12 => println!("我是 {:?} 岁的儿童", n),
        n @ 13..=19 => println!("我是 {:?} 岁的青少年", n),
        // 没有绑定。直接返回结果。
        n => println!("我是 {:?} 岁的成年人", n),
    }
    // 你也可以使用绑定来"解构" enum 变体，例如 Option：
    match some_number() {
        // 匹配到 `Some` 变体，检查其绑定到 `n` 的值
        // 是否等于 42。
        // 也可以使用 `Some(42)` 并打印 `"答案是: 42!"`
        // 但如果想要改变这个值，就需要在两个地方修改 `42`。
        // 也可以使用 `Some(n) if n == 42` 并打印 `"答案是: {n}!"`
        // 但这不是穷尽性检查。
        // （虽然在这种情况下无关紧要，因为
        // 下一个分支是"兜底"模式）
        Some(n @ 42) => println!("答案是：{}！", n),
        // 匹配任何其他数字
        Some(n) => println!("不感兴趣... {}", n),
        // 匹配其他任何情况（`None` 变体）
        _ => (),
    }
}


