// macro_rules!
// Rust 提供了一个强大的宏系统，支持元编程。
// 正如你在前面章节中所看到的，宏看起来像函数，只是它们的名字以感叹号 ! 结尾。
// 但与生成函数调用不同，宏会展开成源代码，然后与程序的其余部分一起编译。
// 与 C 和其他语言中的宏不同，Rust 宏展开成抽象语法树，而不是进行字符串预处理，因此你不会遇到意外的优先级错误。
//
// 宏是使用 macro_rules! 宏来创建的。

// 这是一个名为 `say_hello` 的简单宏。
macro_rules! say_hello {
    // `()` 表示该宏不接受任何参数。
    () => {
        // 宏将展开成这个代码块的内容。
        println!("Hello!")
    };
}

#[test]
fn main() {
    // 这个调用将展开成 `println!("Hello!")`
    say_hello!()
}

// 那么，为什么宏是有用的呢？
//
// 不要重复自己。在许多情况下，你可能需要在多个地方使用相似的功能，但类型不同。
// 通常，编写宏是避免代码重复的有效方法。（稍后会详细介绍）
//
// 领域特定语言。宏允许你为特定目的定义专门的语法。（稍后会详细介绍）
//
// 可变参数接口。有时你可能想定义一个接受可变数量参数的接口。
// 例如 println!，它可以根据格式字符串接受任意数量的参数。（稍后会详细介绍）
